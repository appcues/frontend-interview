"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.b = connect;
exports.d = exports.c = exports.a = void 0;

var _chunkE192c2e = require("./chunk-e192c2e5.js");

var _chunk76875e = require("./chunk-76875e58.js");

var _react3 = require("react");

require("prop-types");

var _chunkCb = require("./chunk-cb015231.js");

var _chunk8219403d = require("./chunk-8219403d.js");

var _chunkEb19ede = require("./chunk-eb19ede6.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (b.hasOwnProperty(p)) d[p] = b[p];
    }
  };

  return _extendStatics(d, b);
};

function __extends(d, b) {
  _extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return _assign.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;
var hasElementType = typeof Element !== 'undefined';

function equal(a, b) {
  if (a === b) return true;

  if (a && b && _typeof(a) == 'object' && _typeof(b) == 'object') {
    var arrA = isArray(a),
        arrB = isArray(b),
        i,
        length,
        key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;

      for (i = length; i-- !== 0;) {
        if (!equal(a[i], b[i])) return false;
      }

      return true;
    }

    if (arrA != arrB) return false;
    var dateA = a instanceof Date,
        dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();
    var regexpA = a instanceof RegExp,
        regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();
    var keys = keyList(a);
    length = keys.length;
    if (length !== keyList(b).length) return false;

    for (i = length; i-- !== 0;) {
      if (!hasProp.call(b, keys[i])) return false;
    }

    if (hasElementType && a instanceof Element && b instanceof Element) return a === b;

    for (i = length; i-- !== 0;) {
      key = keys[i];

      if (key === '_owner' && a.$$typeof) {
        continue;
      } else {
        if (!equal(a[key], b[key])) return false;
      }
    }

    return true;
  }

  return a !== a && b !== b;
}

var reactFastCompare = function exportedEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {
      console.warn('Warning: react-fast-compare does not handle circular references.', error.name, error.message);
      return false;
    }

    throw error;
  }
};

var isMergeableObject = function isMergeableObject(value) {
  return isNonNullObject(value) && !isSpecial(value);
};

function isNonNullObject(value) {
  return !!value && _typeof(value) === 'object';
}

function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
}

var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}

function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}

function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}

function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function (element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}

function mergeObject(target, source, options) {
  var destination = {};

  if (options.isMergeableObject(target)) {
    Object.keys(target).forEach(function (key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }

  Object.keys(source).forEach(function (key) {
    if (!options.isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    } else {
      destination[key] = deepmerge(target[key], source[key], options);
    }
  });
  return destination;
}

function deepmerge(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}

deepmerge.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error('first argument should be an array');
  }

  return array.reduce(function (prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};

var deepmerge_1 = deepmerge;
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[_chunkE192c2e.a.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[_chunkE192c2e.a.Memo] = MEMO_STATICS;

function getStatics(component) {
  if (_chunkE192c2e.a.isMemo(component)) {
    return MEMO_STATICS;
  }

  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

var hoistNonReactStatics_cjs = hoistNonReactStatics;
var key = '__global_unique_id__';

var gud = function gud() {
  return _chunk76875e.a[key] = (_chunk76875e.a[key] || 0) + 1;
};

var implementation = (0, _chunk76875e.c)(function (module, exports) {
  exports.__esModule = true;

  var _react2 = _interopRequireDefault(_chunk8219403d.a);

  var _propTypes2 = _interopRequireDefault(_chunkEb19ede.a);

  var _gud2 = _interopRequireDefault(gud);

  var _warning2 = _interopRequireDefault(_chunkCb.a);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var MAX_SIGNED_31_BIT_INT = 1073741823;

  function objectIs(x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }

  function createEventEmitter(value) {
    var handlers = [];
    return {
      on: function on(handler) {
        handlers.push(handler);
      },
      off: function off(handler) {
        handlers = handlers.filter(function (h) {
          return h !== handler;
        });
      },
      get: function get() {
        return value;
      },
      set: function set(newValue, changedBits) {
        value = newValue;
        handlers.forEach(function (handler) {
          return handler(value, changedBits);
        });
      }
    };
  }

  function onlyChild(children) {
    return Array.isArray(children) ? children[0] : children;
  }

  function createReactContext(defaultValue, calculateChangedBits) {
    var _Provider$childContex, _Consumer$contextType;

    var contextProp = '__create-react-context-' + (0, _gud2.default)() + '__';

    var Provider = function (_Component) {
      _inherits(Provider, _Component);

      function Provider() {
        var _temp, _this, _ret;

        _classCallCheck(this, Provider);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp), _possibleConstructorReturn(_this, _ret);
      }

      Provider.prototype.getChildContext = function getChildContext() {
        var _ref;

        return _ref = {}, _ref[contextProp] = this.emitter, _ref;
      };

      Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (this.props.value !== nextProps.value) {
          var oldValue = this.props.value;
          var newValue = nextProps.value;
          var changedBits = void 0;

          if (objectIs(oldValue, newValue)) {
            changedBits = 0;
          } else {
            changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
            changedBits |= 0;

            if (changedBits !== 0) {
              this.emitter.set(nextProps.value, changedBits);
            }
          }
        }
      };

      Provider.prototype.render = function render() {
        return this.props.children;
      };

      return Provider;
    }(_chunk8219403d.a.Component);

    Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes2.default.object.isRequired, _Provider$childContex);

    var Consumer = function (_Component2) {
      _inherits(Consumer, _Component2);

      function Consumer() {
        var _temp2, _this2, _ret2;

        _classCallCheck(this, Consumer);

        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {
          value: _this2.getValue()
        }, _this2.onUpdate = function (newValue, changedBits) {
          var observedBits = _this2.observedBits | 0;

          if ((observedBits & changedBits) !== 0) {
            _this2.setState({
              value: _this2.getValue()
            });
          }
        }, _temp2), _possibleConstructorReturn(_this2, _ret2);
      }

      Consumer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var observedBits = nextProps.observedBits;
        this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
      };

      Consumer.prototype.componentDidMount = function componentDidMount() {
        if (this.context[contextProp]) {
          this.context[contextProp].on(this.onUpdate);
        }

        var observedBits = this.props.observedBits;
        this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
      };

      Consumer.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.context[contextProp]) {
          this.context[contextProp].off(this.onUpdate);
        }
      };

      Consumer.prototype.getValue = function getValue() {
        if (this.context[contextProp]) {
          return this.context[contextProp].get();
        } else {
          return defaultValue;
        }
      };

      Consumer.prototype.render = function render() {
        return onlyChild(this.props.children)(this.state.value);
      };

      return Consumer;
    }(_chunk8219403d.a.Component);

    Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes2.default.object, _Consumer$contextType);
    return {
      Provider: Provider,
      Consumer: Consumer
    };
  }

  exports.default = createReactContext;
  module.exports = exports['default'];
});
(0, _chunk76875e.b)(implementation);
var lib = (0, _chunk76875e.c)(function (module, exports) {
  exports.__esModule = true;

  var _react2 = _interopRequireDefault(_chunk8219403d.a);

  var _implementation2 = _interopRequireDefault(implementation);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  exports.default = _react2.default.createContext || _implementation2.default;
  module.exports = exports['default'];
});
var createContext = (0, _chunk76875e.b)(lib);

function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

function eq(value, other) {
  return value === other || value !== value && other !== other;
}

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

var arrayProto = Array.prototype;
var splice = arrayProto.splice;

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

function stackGet(key) {
  return this.__data__.get(key);
}

function stackHas(key) {
  return this.__data__.has(key);
}

var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
var Symbol$1 = root.Symbol;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

var objectProto$1 = Object.prototype;
var nativeObjectToString$1 = objectProto$1.toString;

function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
}

function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }

  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var coreJsData = root['__core-js_shared__'];

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

var funcProto = Function.prototype;
var funcToString = funcProto.toString;

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

function getValue(object, key) {
  return object == null ? undefined : object[key];
}

function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var Map$1 = getNative(root, 'Map');
var nativeCreate = getNative(Object, 'create');

function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var HASH_UNDEFINED = '__lodash_hash_undefined__';
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
}

var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
}

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map$1 || ListCache)(),
    'string': new Hash()
  };
}

function isKeyable(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

var defineProperty$1 = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$4.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

var argsTag = '[object Arguments]';

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty$5.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
var isArray$1 = Array.isArray;

function stubFalse() {
  return false;
}

var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root.Buffer : undefined;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
var isBuffer = nativeIsBuffer || stubFalse;
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

var MAX_SAFE_INTEGER$1 = 9007199254740991;

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

var freeExports$1 = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal.process;

var nodeUtil = function () {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

var objectProto$8 = Object.prototype;

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$8;
  return value === proto;
}

function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

var nativeKeys = overArg(Object.keys, Object);
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

function keysIn$1(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn$1(source), object);
}

var freeExports$2 = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

function stubArray() {
  return [];
}

var objectProto$b = Object.prototype;
var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

var getPrototype = overArg(Object.getPrototypeOf, Object);
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols$1 ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};

function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}

function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}

var DataView = getNative(root, 'DataView');
var Promise$1 = getNative(root, 'Promise');
var Set = getNative(root, 'Set');
var WeakMap$1 = getNative(root, 'WeakMap');
var mapTag$1 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$1 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';
var dataViewTag$1 = '[object DataView]';
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set && getTag(new Set()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
  getTag = function getTag(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;

        case mapCtorString:
          return mapTag$1;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag$1;

        case weakMapCtorString:
          return weakMapTag$1;
      }
    }

    return result;
  };
}

var getTag$1 = getTag;
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  if (length && typeof array[0] == 'string' && hasOwnProperty$9.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

var Uint8Array = root.Uint8Array;

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

var reFlags = /\w*$/;

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);

    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);

    case dataViewTag$2:
      return cloneDataView(object, isDeep);

    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$2:
      return new Ctor();

    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);

    case regexpTag$1:
      return cloneRegExp(object);

    case setTag$2:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

var objectCreate = Object.create;

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

var mapTag$3 = '[object Map]';

function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$3;
}

var nodeIsMap = nodeUtil && nodeUtil.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var setTag$3 = '[object Set]';

function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$3;
}

var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$2 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    mapTag$4 = '[object Map]',
    numberTag$2 = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag$2 = '[object RegExp]',
    setTag$4 = '[object Set]',
    stringTag$2 = '[object String]',
    symbolTag$1 = '[object Symbol]',
    weakMapTag$2 = '[object WeakMap]';
var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$3 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';
var cloneableTags = {};
cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] = cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] = cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$2] = cloneableTags[setTag$4] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] = cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray$1(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value),
        isFunc = tag == funcTag$2 || tag == genTag$1;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag$2 || tag == argsTag$2 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  }

  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }

    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

var CLONE_SYMBOLS_FLAG$1 = 4;

function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG$1);
}

function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

var symbolTag$2 = '[object Symbol]';

function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag$2;
}

var FUNC_ERROR_TEXT = 'Expected a function';

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}

memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46) {
    result.push('');
  }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
var INFINITY = 1 / 0;

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

var INFINITY$1 = 1 / 0;
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

function baseToString(value) {
  if (typeof value == 'string') {
    return value;
  }

  if (isArray$1(value)) {
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
}

function toString(value) {
  return value == null ? '' : baseToString(value);
}

function toPath(value) {
  if (isArray$1(value)) {
    return arrayMap(value, toKey);
  }

  return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
}

var CLONE_DEEP_FLAG$1 = 1,
    CLONE_SYMBOLS_FLAG$2 = 4;

function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$2);
}

var _a;

var FormikProvider = (_a = createContext({}), _a.Provider),
    FormikConsumer = _a.Consumer;

function connect(Comp) {
  var C = function C(props) {
    return (0, _react3.createElement)(FormikConsumer, null, function (formik) {
      return (0, _react3.createElement)(Comp, _assign({}, props, {
        formik: formik
      }));
    });
  };

  var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || 'Component';
  C.WrappedComponent = Comp;
  C.displayName = "FormikConnect(" + componentDisplayName + ")";
  return hoistNonReactStatics_cjs(C, Comp);
}

var isFunction$1 = function isFunction$1(obj) {
  return typeof obj === 'function';
};

var isObject$1 = function isObject$1(obj) {
  return obj !== null && _typeof(obj) === 'object';
};

var isInteger = function isInteger(obj) {
  return String(Math.floor(Number(obj))) === obj;
};

var isString = function isString(obj) {
  return Object.prototype.toString.call(obj) === '[object String]';
};

var isNaN$1 = function isNaN$1(obj) {
  return obj !== obj;
};

var isEmptyChildren = function isEmptyChildren(children) {
  return _react3.Children.count(children) === 0;
};

var isPromise = function isPromise(value) {
  return isObject$1(value) && isFunction$1(value.then);
};

var isInputEvent = function isInputEvent(value) {
  return value && isObject$1(value) && isObject$1(value.target);
};

function makeCancelable(promise) {
  var hasCanceled = false;
  var wrappedPromise = new Promise(function (resolve, reject) {
    promise.then(function (val) {
      return hasCanceled ? reject({
        isCanceled: true
      }) : resolve(val);
    }, function (error) {
      return hasCanceled ? reject({
        isCanceled: true
      }) : reject(error);
    });
  });
  return [wrappedPromise, function cancel() {
    hasCanceled = true;
  }];
}

function getIn(obj, key, def, p) {
  if (p === void 0) {
    p = 0;
  }

  var path = toPath(key);

  while (obj && p < path.length) {
    obj = obj[path[p++]];
  }

  return obj === undefined ? def : obj;
}

function setIn(obj, path, value) {
  var res = clone(obj);
  var resVal = res;
  var i = 0;
  var pathArray = toPath(path);

  for (; i < pathArray.length - 1; i++) {
    var currentPath = pathArray[i];
    var currentObj = getIn(obj, pathArray.slice(0, i + 1));

    if (currentObj) {
      resVal = resVal[currentPath] = clone(currentObj);
    } else {
      var nextPath = pathArray[i + 1];
      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
    }
  }

  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {
    return obj;
  }

  if (value === undefined) {
    delete resVal[pathArray[i]];
  } else {
    resVal[pathArray[i]] = value;
  }

  if (i === 0 && value === undefined) {
    delete res[pathArray[i]];
  }

  return res;
}

function setNestedObjectValues(object, value, visited, response) {
  if (visited === void 0) {
    visited = new WeakMap();
  }

  if (response === void 0) {
    response = {};
  }

  for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
    var k = _a[_i];
    var val = object[k];

    if (isObject$1(val)) {
      if (!visited.get(val)) {
        visited.set(val, true);
        response[k] = Array.isArray(val) ? [] : {};
        setNestedObjectValues(val, value, visited, response[k]);
      }
    } else {
      response[k] = value;
    }
  }

  return response;
}

var Formik = function (_super) {
  __extends(Formik, _super);

  function Formik(props) {
    var _this = _super.call(this, props) || this;

    _this.hcCache = {};
    _this.hbCache = {};

    _this.registerField = function (name, Comp) {
      _this.fields[name] = Comp;
    };

    _this.unregisterField = function (name) {
      delete _this.fields[name];
    };

    _this.setErrors = function (errors) {
      _this.setState({
        errors: errors
      });
    };

    _this.setTouched = function (touched) {
      _this.setState({
        touched: touched
      }, function () {
        if (_this.props.validateOnBlur) {
          _this.runValidations(_this.state.values);
        }
      });
    };

    _this.setValues = function (values) {
      _this.setState({
        values: values
      }, function () {
        if (_this.props.validateOnChange) {
          _this.runValidations(values);
        }
      });
    };

    _this.setStatus = function (status) {
      _this.setState({
        status: status
      });
    };

    _this.setError = function (error) {
      _this.setState({
        error: error
      });
    };

    _this.setSubmitting = function (isSubmitting) {
      if (_this.didMount) {
        _this.setState({
          isSubmitting: isSubmitting
        });
      }
    };

    _this.validateField = function (field) {
      _this.setState({
        isValidating: true
      });

      return _this.runSingleFieldLevelValidation(field, getIn(_this.state.values, field)).then(function (error) {
        if (_this.didMount) {
          _this.setState({
            errors: setIn(_this.state.errors, field, error),
            isValidating: false
          });
        }

        return error;
      });
    };

    _this.runSingleFieldLevelValidation = function (field, value) {
      return new Promise(function (resolve) {
        return resolve(_this.fields[field].props.validate(value));
      }).then(function (x) {
        return x;
      }, function (e) {
        return e;
      });
    };

    _this.runValidationSchema = function (values) {
      return new Promise(function (resolve) {
        var validationSchema = _this.props.validationSchema;
        var schema = isFunction$1(validationSchema) ? validationSchema() : validationSchema;
        validateYupSchema(values, schema).then(function () {
          resolve({});
        }, function (err) {
          resolve(yupToFormErrors(err));
        });
      });
    };

    _this.runValidations = function (values) {
      if (values === void 0) {
        values = _this.state.values;
      }

      if (_this.validator) {
        _this.validator();
      }

      var _a = makeCancelable(Promise.all([_this.runFieldLevelValidations(values), _this.props.validationSchema ? _this.runValidationSchema(values) : {}, _this.props.validate ? _this.runValidateHandler(values) : {}]).then(function (_a) {
        var fieldErrors = _a[0],
            schemaErrors = _a[1],
            handlerErrors = _a[2];
        return deepmerge_1.all([fieldErrors, schemaErrors, handlerErrors], {
          arrayMerge: arrayMerge
        });
      })),
          promise = _a[0],
          cancel = _a[1];

      _this.validator = cancel;
      return promise.then(function (errors) {
        if (_this.didMount) {
          _this.setState(function (prevState) {
            if (!reactFastCompare(prevState.errors, errors)) {
              return {
                errors: errors
              };
            }

            return null;
          });
        }

        return errors;
      }).catch(function (x) {
        return x;
      });
    };

    _this.handleChange = function (eventOrPath) {
      var executeChange = function executeChange(eventOrValue, maybePath) {
        var field = maybePath;
        var value;

        if (isInputEvent(eventOrValue)) {
          var event_1 = eventOrValue;

          if (event_1.persist) {
            event_1.persist();
          }

          var _a = event_1.target,
              type = _a.type,
              name_1 = _a.name,
              id = _a.id,
              checked = _a.checked,
              outerHTML = _a.outerHTML;
          field = maybePath ? maybePath : name_1 ? name_1 : id;

          if (!field && "production" !== 'production') {
            warnAboutMissingIdentifier({
              htmlContent: outerHTML,
              documentationAnchorLink: 'handlechange-e-reactchangeeventany--void',
              handlerName: 'handleChange'
            });
          }

          value = event_1.target.value;

          if (/number|range/.test(type)) {
            var parsed = parseFloat(event_1.target.value);
            value = isNaN$1(parsed) ? '' : parsed;
          }

          if (/checkbox/.test(type)) {
            value = checked;
          }
        } else {
          value = eventOrValue;
        }

        if (field) {
          _this.setState(function (prevState) {
            return _assign({}, prevState, {
              values: setIn(prevState.values, field, value)
            });
          }, function () {
            if (_this.props.validateOnChange) {
              _this.runValidations(setIn(_this.state.values, field, value));
            }
          });
        }
      };

      if (isString(eventOrPath)) {
        var path_1 = eventOrPath;

        if (!isFunction$1(_this.hcCache[path_1])) {
          _this.hcCache[path_1] = function (eventOrValue) {
            return executeChange(eventOrValue, path_1);
          };
        }

        return _this.hcCache[path_1];
      } else {
        var event_2 = eventOrPath;
        executeChange(event_2);
      }
    };

    _this.setFieldValue = function (field, value, shouldValidate) {
      if (shouldValidate === void 0) {
        shouldValidate = true;
      }

      if (_this.didMount) {
        _this.setState(function (prevState) {
          return _assign({}, prevState, {
            values: setIn(prevState.values, field, value)
          });
        }, function () {
          if (_this.props.validateOnChange && shouldValidate) {
            _this.runValidations(_this.state.values);
          }
        });
      }
    };

    _this.handleSubmit = function (e) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }

      _this.submitForm();
    };

    _this.submitForm = function () {
      _this.setState(function (prevState) {
        return {
          touched: setNestedObjectValues(prevState.values, true),
          isSubmitting: true,
          isValidating: true,
          submitCount: prevState.submitCount + 1
        };
      });

      return _this.runValidations(_this.state.values).then(function (combinedErrors) {
        if (_this.didMount) {
          _this.setState({
            isValidating: false
          });
        }

        var isValid = Object.keys(combinedErrors).length === 0;

        if (isValid) {
          _this.executeSubmit();
        } else if (_this.didMount) {
          _this.setState({
            isSubmitting: false
          });
        }
      });
    };

    _this.executeSubmit = function () {
      _this.props.onSubmit(_this.state.values, _this.getFormikActions());
    };

    _this.handleBlur = function (eventOrPath) {
      var executeBlur = function executeBlur(maybeEvent, maybePath) {
        var field = maybePath;

        if (isInputEvent(maybeEvent)) {
          var event_3 = maybeEvent;

          if (event_3.persist) {
            event_3.persist();
          }

          var _a = event_3.target,
              name_2 = _a.name,
              id = _a.id,
              outerHTML = _a.outerHTML;
          field = name_2 ? name_2 : id;

          if (!field && "production" !== 'production') {
            warnAboutMissingIdentifier({
              htmlContent: outerHTML,
              documentationAnchorLink: 'handleblur-e-reactfocuseventany--void',
              handlerName: 'handleBlur'
            });
          }
        }

        _this.setState(function (prevState) {
          return {
            touched: setIn(prevState.touched, field, true)
          };
        });

        if (_this.props.validateOnBlur) {
          _this.runValidations(_this.state.values);
        }
      };

      if (isString(eventOrPath)) {
        var path_2 = eventOrPath;

        if (!isFunction$1(_this.hbCache[path_2])) {
          _this.hbCache[path_2] = function (event) {
            return executeBlur(event, path_2);
          };
        }

        return _this.hbCache[path_2];
      } else {
        var event_4 = eventOrPath;
        executeBlur(event_4);
      }
    };

    _this.setFieldTouched = function (field, touched, shouldValidate) {
      if (touched === void 0) {
        touched = true;
      }

      if (shouldValidate === void 0) {
        shouldValidate = true;
      }

      _this.setState(function (prevState) {
        return _assign({}, prevState, {
          touched: setIn(prevState.touched, field, touched)
        });
      }, function () {
        if (_this.props.validateOnBlur && shouldValidate) {
          _this.runValidations(_this.state.values);
        }
      });
    };

    _this.setFieldError = function (field, message) {
      _this.setState(function (prevState) {
        return _assign({}, prevState, {
          errors: setIn(prevState.errors, field, message)
        });
      });
    };

    _this.resetForm = function (nextValues) {
      var values = nextValues ? nextValues : _this.props.initialValues;
      _this.initialValues = values;

      _this.setState({
        isSubmitting: false,
        isValidating: false,
        errors: {},
        touched: {},
        error: undefined,
        status: _this.props.initialStatus,
        values: values,
        submitCount: 0
      });
    };

    _this.handleReset = function () {
      if (_this.props.onReset) {
        var maybePromisedOnReset = _this.props.onReset(_this.state.values, _this.getFormikActions());

        if (isPromise(maybePromisedOnReset)) {
          maybePromisedOnReset.then(_this.resetForm);
        } else {
          _this.resetForm();
        }
      } else {
        _this.resetForm();
      }
    };

    _this.setFormikState = function (s, callback) {
      return _this.setState(s, callback);
    };

    _this.validateForm = function (values) {
      _this.setState({
        isValidating: true
      });

      return _this.runValidations(values).then(function (errors) {
        if (_this.didMount) {
          _this.setState({
            isValidating: false
          });
        }

        return errors;
      });
    };

    _this.getFormikActions = function () {
      return {
        resetForm: _this.resetForm,
        submitForm: _this.submitForm,
        validateForm: _this.validateForm,
        validateField: _this.validateField,
        setError: _this.setError,
        setErrors: _this.setErrors,
        setFieldError: _this.setFieldError,
        setFieldTouched: _this.setFieldTouched,
        setFieldValue: _this.setFieldValue,
        setStatus: _this.setStatus,
        setSubmitting: _this.setSubmitting,
        setTouched: _this.setTouched,
        setValues: _this.setValues,
        setFormikState: _this.setFormikState
      };
    };

    _this.getFormikComputedProps = function () {
      var isInitialValid = _this.props.isInitialValid;
      var dirty = !reactFastCompare(_this.initialValues, _this.state.values);
      return {
        dirty: dirty,
        isValid: dirty ? _this.state.errors && Object.keys(_this.state.errors).length === 0 : isInitialValid !== false && isFunction$1(isInitialValid) ? isInitialValid(_this.props) : isInitialValid,
        initialValues: _this.initialValues
      };
    };

    _this.getFormikBag = function () {
      return _assign({}, _this.state, _this.getFormikActions(), _this.getFormikComputedProps(), {
        registerField: _this.registerField,
        unregisterField: _this.unregisterField,
        handleBlur: _this.handleBlur,
        handleChange: _this.handleChange,
        handleReset: _this.handleReset,
        handleSubmit: _this.handleSubmit,
        validateOnChange: _this.props.validateOnChange,
        validateOnBlur: _this.props.validateOnBlur
      });
    };

    _this.getFormikContext = function () {
      return _assign({}, _this.getFormikBag(), {
        validationSchema: _this.props.validationSchema,
        validate: _this.props.validate,
        initialValues: _this.initialValues
      });
    };

    _this.state = {
      values: props.initialValues || {},
      errors: {},
      touched: {},
      isSubmitting: false,
      isValidating: false,
      submitCount: 0,
      status: props.initialStatus
    };
    _this.didMount = false;
    _this.fields = {};
    _this.initialValues = props.initialValues || {};
    return _this;
  }

  Formik.prototype.componentDidMount = function () {
    this.didMount = true;
  };

  Formik.prototype.componentWillUnmount = function () {
    this.didMount = false;

    if (this.validator) {
      this.validator();
    }
  };

  Formik.prototype.componentDidUpdate = function (prevProps) {
    if (this.props.enableReinitialize && !reactFastCompare(prevProps.initialValues, this.props.initialValues)) {
      this.initialValues = this.props.initialValues;
      this.resetForm(this.props.initialValues);
    }
  };

  Formik.prototype.runFieldLevelValidations = function (values) {
    var _this = this;

    var fieldKeysWithValidation = Object.keys(this.fields).filter(function (f) {
      return _this.fields && _this.fields[f] && _this.fields[f].props.validate && isFunction$1(_this.fields[f].props.validate);
    });
    var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function (f) {
      return _this.runSingleFieldLevelValidation(f, getIn(values, f));
    }) : [Promise.resolve('DO_NOT_DELETE_YOU_WILL_BE_FIRED')];
    return Promise.all(fieldValidations).then(function (fieldErrorsList) {
      return fieldErrorsList.reduce(function (prev, curr, index) {
        if (curr === 'DO_NOT_DELETE_YOU_WILL_BE_FIRED') {
          return prev;
        }

        if (!!curr) {
          prev = setIn(prev, fieldKeysWithValidation[index], curr);
        }

        return prev;
      }, {});
    });
  };

  Formik.prototype.runValidateHandler = function (values) {
    var _this = this;

    return new Promise(function (resolve) {
      var maybePromisedErrors = _this.props.validate(values);

      if (maybePromisedErrors === undefined) {
        resolve({});
      } else if (isPromise(maybePromisedErrors)) {
        maybePromisedErrors.then(function () {
          resolve({});
        }, function (errors) {
          resolve(errors);
        });
      } else {
        resolve(maybePromisedErrors);
      }
    });
  };

  Formik.prototype.render = function () {
    var _a = this.props,
        component = _a.component,
        render = _a.render,
        children = _a.children;
    var props = this.getFormikBag();
    var ctx = this.getFormikContext();
    return (0, _react3.createElement)(FormikProvider, {
      value: ctx
    }, component ? (0, _react3.createElement)(component, props) : render ? render(props) : children ? isFunction$1(children) ? children(props) : !isEmptyChildren(children) ? _react3.Children.only(children) : null : null);
  };

  Formik.defaultProps = {
    validateOnChange: true,
    validateOnBlur: true,
    isInitialValid: false,
    enableReinitialize: false
  };
  return Formik;
}(_react3.Component);

exports.c = Formik;

function warnAboutMissingIdentifier(_a) {
  var htmlContent = _a.htmlContent,
      documentationAnchorLink = _a.documentationAnchorLink,
      handlerName = _a.handlerName;
  console.warn("Warning: Formik called `" + handlerName + "`, but you forgot to pass an `id` or `name` attribute to your input:\n\n    " + htmlContent + "\n\n    Formik cannot determine which value to update. For more info see https://github.com/jaredpalmer/formik#" + documentationAnchorLink + "\n  ");
}

function yupToFormErrors(yupError) {
  var errors = {};

  if (yupError.inner.length === 0) {
    return setIn(errors, yupError.path, yupError.message);
  }

  for (var _i = 0, _a = yupError.inner; _i < _a.length; _i++) {
    var err = _a[_i];

    if (!errors[err.path]) {
      errors = setIn(errors, err.path, err.message);
    }
  }

  return errors;
}

function validateYupSchema(values, schema, sync, context) {
  if (sync === void 0) {
    sync = false;
  }

  if (context === void 0) {
    context = {};
  }

  var validateData = {};

  for (var k in values) {
    if (values.hasOwnProperty(k)) {
      var key = String(k);
      validateData[key] = values[key] !== '' ? values[key] : undefined;
    }
  }

  return schema[sync ? 'validateSync' : 'validate'](validateData, {
    abortEarly: false,
    context: context
  });
}

function arrayMerge(target, source, options) {
  var destination = target.slice();
  source.forEach(function (e, i) {
    if (typeof destination[i] === 'undefined') {
      var cloneRequested = options.clone !== false;
      var shouldClone = cloneRequested && options.isMergeableObject(e);
      destination[i] = shouldClone ? deepmerge_1(Array.isArray(e) ? [] : {}, e, options) : e;
    } else if (options.isMergeableObject(e)) {
      destination[i] = deepmerge_1(target[i], e, options);
    } else if (target.indexOf(e) === -1) {
      destination.push(e);
    }
  });
  return destination;
}

var FieldInner = function (_super) {
  __extends(FieldInner, _super);

  function FieldInner(props) {
    var _this = _super.call(this, props) || this;

    var render = props.render,
        children = props.children,
        component = props.component;
    return _this;
  }

  FieldInner.prototype.componentDidMount = function () {
    this.props.formik.registerField(this.props.name, this);
  };

  FieldInner.prototype.componentDidUpdate = function (prevProps) {
    if (this.props.name !== prevProps.name) {
      this.props.formik.unregisterField(prevProps.name);
      this.props.formik.registerField(this.props.name, this);
    }

    if (this.props.validate !== prevProps.validate) {
      this.props.formik.registerField(this.props.name, this);
    }
  };

  FieldInner.prototype.componentWillUnmount = function () {
    this.props.formik.unregisterField(this.props.name);
  };

  FieldInner.prototype.render = function () {
    var _a = this.props,
        validate = _a.validate,
        name = _a.name,
        render = _a.render,
        children = _a.children,
        _b = _a.component,
        component = _b === void 0 ? 'input' : _b,
        formik = _a.formik,
        props = __rest(_a, ["validate", "name", "render", "children", "component", "formik"]);

    var _validate = formik.validate,
        _validationSchema = formik.validationSchema,
        restOfFormik = __rest(formik, ["validate", "validationSchema"]);

    var field = {
      value: props.type === 'radio' || props.type === 'checkbox' ? props.value : getIn(formik.values, name),
      name: name,
      onChange: formik.handleChange,
      onBlur: formik.handleBlur
    };
    var bag = {
      field: field,
      form: restOfFormik
    };

    if (render) {
      return render(bag);
    }

    if (isFunction$1(children)) {
      return children(bag);
    }

    if (typeof component === 'string') {
      var innerRef = props.innerRef,
          rest = __rest(props, ["innerRef"]);

      return (0, _react3.createElement)(component, _assign({
        ref: innerRef
      }, field, rest, {
        children: children
      }));
    }

    return (0, _react3.createElement)(component, _assign({}, bag, props, {
      children: children
    }));
  };

  return FieldInner;
}(_react3.Component);

var Field = connect(FieldInner);
exports.a = Field;
var Form = connect(function (_a) {
  var _b = _a.formik,
      handleReset = _b.handleReset,
      handleSubmit = _b.handleSubmit,
      props = __rest(_a, ["formik"]);

  return (0, _react3.createElement)("form", _assign({
    onReset: handleReset,
    onSubmit: handleSubmit
  }, props));
});
exports.d = Form;
Form.displayName = 'Form';

var move = function move(array, from, to) {
  var copy = (array || []).slice();
  var value = copy[from];
  copy.splice(from, 1);
  copy.splice(to, 0, value);
  return copy;
};

var swap = function swap(array, indexA, indexB) {
  var copy = (array || []).slice();
  var a = copy[indexA];
  copy[indexA] = copy[indexB];
  copy[indexB] = a;
  return copy;
};

var insert = function insert(array, index, value) {
  var copy = (array || []).slice();
  copy.splice(index, 0, value);
  return copy;
};

var replace = function replace(array, index, value) {
  var copy = (array || []).slice();
  copy[index] = value;
  return copy;
};

var FieldArrayInner = function (_super) {
  __extends(FieldArrayInner, _super);

  function FieldArrayInner(props) {
    var _this = _super.call(this, props) || this;

    _this.updateArrayField = function (fn, alterTouched, alterErrors) {
      var _a = _this.props,
          name = _a.name,
          validateOnChange = _a.validateOnChange,
          _b = _a.formik,
          setFormikState = _b.setFormikState,
          validateForm = _b.validateForm;
      setFormikState(function (prevState) {
        var updateErrors = typeof alterErrors === 'function' ? alterErrors : fn;
        var updateTouched = typeof alterTouched === 'function' ? alterTouched : fn;
        return _assign({}, prevState, {
          values: setIn(prevState.values, name, fn(getIn(prevState.values, name))),
          errors: alterErrors ? setIn(prevState.errors, name, updateErrors(getIn(prevState.errors, name))) : prevState.errors,
          touched: alterTouched ? setIn(prevState.touched, name, updateTouched(getIn(prevState.touched, name))) : prevState.touched
        });
      }, function () {
        if (validateOnChange) {
          validateForm();
        }
      });
    };

    _this.push = function (value) {
      return _this.updateArrayField(function (array) {
        return (array || []).concat([cloneDeep(value)]);
      }, false, false);
    };

    _this.handlePush = function (value) {
      return function () {
        return _this.push(value);
      };
    };

    _this.swap = function (indexA, indexB) {
      return _this.updateArrayField(function (array) {
        return swap(array, indexA, indexB);
      }, true, true);
    };

    _this.handleSwap = function (indexA, indexB) {
      return function () {
        return _this.swap(indexA, indexB);
      };
    };

    _this.move = function (from, to) {
      return _this.updateArrayField(function (array) {
        return move(array, from, to);
      }, true, true);
    };

    _this.handleMove = function (from, to) {
      return function () {
        return _this.move(from, to);
      };
    };

    _this.insert = function (index, value) {
      return _this.updateArrayField(function (array) {
        return insert(array, index, value);
      }, function (array) {
        return insert(array, index, null);
      }, function (array) {
        return insert(array, index, null);
      });
    };

    _this.handleInsert = function (index, value) {
      return function () {
        return _this.insert(index, value);
      };
    };

    _this.replace = function (index, value) {
      return _this.updateArrayField(function (array) {
        return replace(array, index, value);
      }, false, false);
    };

    _this.handleReplace = function (index, value) {
      return function () {
        return _this.replace(index, value);
      };
    };

    _this.unshift = function (value) {
      var length = -1;

      _this.updateArrayField(function (array) {
        var arr = array ? [value].concat(array) : [value];

        if (length < 0) {
          length = arr.length;
        }

        return arr;
      }, function (array) {
        var arr = array ? [null].concat(array) : [null];
        if (length < 0) length = arr.length;
        return arr;
      }, function (array) {
        var arr = array ? [null].concat(array) : [null];
        if (length < 0) length = arr.length;
        return arr;
      });

      return length;
    };

    _this.handleUnshift = function (value) {
      return function () {
        return _this.unshift(value);
      };
    };

    _this.handleRemove = function (index) {
      return function () {
        return _this.remove(index);
      };
    };

    _this.handlePop = function () {
      return function () {
        return _this.pop();
      };
    };

    _this.remove = _this.remove.bind(_this);
    _this.pop = _this.pop.bind(_this);
    return _this;
  }

  FieldArrayInner.prototype.remove = function (index) {
    var result;
    this.updateArrayField(function (array) {
      var copy = array ? array.slice() : [];

      if (!result) {
        result = copy[index];
      }

      if (isFunction$1(copy.splice)) {
        copy.splice(index, 1);
      }

      return copy;
    }, true, true);
    return result;
  };

  FieldArrayInner.prototype.pop = function () {
    var result;
    this.updateArrayField(function (array) {
      var tmp = array;

      if (!result) {
        result = tmp && tmp.pop && tmp.pop();
      }

      return tmp;
    }, true, true);
    return result;
  };

  FieldArrayInner.prototype.render = function () {
    var arrayHelpers = {
      push: this.push,
      pop: this.pop,
      swap: this.swap,
      move: this.move,
      insert: this.insert,
      replace: this.replace,
      unshift: this.unshift,
      remove: this.remove,
      handlePush: this.handlePush,
      handlePop: this.handlePop,
      handleSwap: this.handleSwap,
      handleMove: this.handleMove,
      handleInsert: this.handleInsert,
      handleReplace: this.handleReplace,
      handleUnshift: this.handleUnshift,
      handleRemove: this.handleRemove
    };

    var _a = this.props,
        component = _a.component,
        render = _a.render,
        children = _a.children,
        name = _a.name,
        _b = _a.formik,
        _validate = _b.validate,
        _validationSchema = _b.validationSchema,
        restOfFormik = __rest(_b, ["validate", "validationSchema"]);

    var props = _assign({}, arrayHelpers, {
      form: restOfFormik,
      name: name
    });

    return component ? (0, _react3.createElement)(component, props) : render ? render(props) : children ? typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? _react3.Children.only(children) : null : null;
  };

  FieldArrayInner.defaultProps = {
    validateOnChange: true
  };
  return FieldArrayInner;
}(_react3.Component);

var FieldArray = connect(FieldArrayInner);

var FastFieldInner = function (_super) {
  __extends(FastFieldInner, _super);

  function FastFieldInner(props) {
    var _this = _super.call(this, props) || this;

    var render = props.render,
        children = props.children,
        component = props.component;
    return _this;
  }

  FastFieldInner.prototype.shouldComponentUpdate = function (props) {
    if (this.props.shouldUpdate) {
      return this.props.shouldUpdate(props, this.props);
    } else if (getIn(this.props.formik.values, this.props.name) !== getIn(props.formik.values, this.props.name) || getIn(this.props.formik.errors, this.props.name) !== getIn(props.formik.errors, this.props.name) || getIn(this.props.formik.touched, this.props.name) !== getIn(props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length || this.props.formik.isSubmitting !== props.formik.isSubmitting) {
      return true;
    } else {
      return false;
    }
  };

  FastFieldInner.prototype.componentDidMount = function () {
    this.props.formik.registerField(this.props.name, this);
  };

  FastFieldInner.prototype.componentDidUpdate = function (prevProps) {
    if (this.props.name !== prevProps.name) {
      this.props.formik.unregisterField(prevProps.name);
      this.props.formik.registerField(this.props.name, this);
    }

    if (this.props.validate !== prevProps.validate) {
      this.props.formik.registerField(this.props.name, this);
    }
  };

  FastFieldInner.prototype.componentWillUnmount = function () {
    this.props.formik.unregisterField(this.props.name);
  };

  FastFieldInner.prototype.render = function () {
    var _a = this.props,
        validate = _a.validate,
        name = _a.name,
        render = _a.render,
        children = _a.children,
        _b = _a.component,
        component = _b === void 0 ? 'input' : _b,
        formik = _a.formik,
        shouldUpdate = _a.shouldUpdate,
        props = __rest(_a, ["validate", "name", "render", "children", "component", "formik", "shouldUpdate"]);

    var _validate = formik.validate,
        _validationSchema = formik.validationSchema,
        restOfFormik = __rest(formik, ["validate", "validationSchema"]);

    var field = {
      value: props.type === 'radio' || props.type === 'checkbox' ? props.value : getIn(formik.values, name),
      name: name,
      onChange: formik.handleChange,
      onBlur: formik.handleBlur
    };
    var bag = {
      field: field,
      form: restOfFormik
    };

    if (render) {
      return render(bag);
    }

    if (isFunction$1(children)) {
      return children(bag);
    }

    if (typeof component === 'string') {
      var innerRef = props.innerRef,
          rest = __rest(props, ["innerRef"]);

      return (0, _react3.createElement)(component, _assign({
        ref: innerRef
      }, field, rest, {
        children: children
      }));
    }

    return (0, _react3.createElement)(component, _assign({}, bag, props, {
      children: children
    }));
  };

  return FastFieldInner;
}(_react3.Component);

var FastField = connect(FastFieldInner);

var ErrorMessageImpl = function (_super) {
  __extends(ErrorMessageImpl, _super);

  function ErrorMessageImpl() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ErrorMessageImpl.prototype.shouldComponentUpdate = function (props) {
    if (getIn(this.props.formik.errors, this.props.name) !== getIn(props.formik.errors, this.props.name) || getIn(this.props.formik.touched, this.props.name) !== getIn(props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length) {
      return true;
    } else {
      return false;
    }
  };

  ErrorMessageImpl.prototype.render = function () {
    var _a = this.props,
        component = _a.component,
        formik = _a.formik,
        render = _a.render,
        children = _a.children,
        name = _a.name,
        rest = __rest(_a, ["component", "formik", "render", "children", "name"]);

    var touch = getIn(formik.touched, name);
    var error = getIn(formik.errors, name);
    return !!touch && !!error ? render ? isFunction$1(render) ? render(error) : null : children ? isFunction$1(children) ? children(error) : null : component ? (0, _react3.createElement)(component, rest, error) : error : null;
  };

  return ErrorMessageImpl;
}(_react3.Component);

var ErrorMessage = connect(ErrorMessageImpl);